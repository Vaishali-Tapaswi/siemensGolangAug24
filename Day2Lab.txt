Lab8 - 
        package main
        import (
        	"fmt"
        	"strconv"
        )
        
        
        func main() {
        
        	ch := make(chan string, 3)
        	go sender(ch, "a")
        	go receiver(ch)
        	for{}
        	
        }
        func receiver(ch chan string) {
        	    for str := range ch {
        			fmt.Println("Received " , str)	
        		}
        		fmt.Println("Out of for loop in Receiver")
        }
        func sender(ch chan string, str string) {
        	for i := 0; i < 15; i++ {
        		fmt.Println("starting to send data on channel " , i)
        		n1 := strconv.Itoa(i)
        		ch <- "send"+n1
        	}
        	close(ch)
        }

Lab7 - channel
        package main
        
        import "fmt"
        
        func main() {
        	ch := make(chan string)
        	go send(ch, "a")
        	//fmt.Print(ch)
        	fmt.Println("waiting in main for channel data ")
        	str := <-ch   
        	fmt.Println("Received " , str)
        	fmt.Println("waiting for one for data")
        	str = <-ch   
        	fmt.Println("Received " , str)
        	for{}
        	
        }
        
        func send(ch chan string, str string) {
        	//for i := 0; i < 1000; i++ {
        		fmt.Println("starting to send data on channel")
        		ch <- "send1"    
        		fmt.Println("after sending data on channel")
        		ch <- "send2"
        }

Lab6 - 3 options -> car1, car2, car3 
        whichever car finishes first is the winner and once any car wins all others should stop 
Lab5 - simple demo for goroutines

    package main
    
    import "fmt"
    
    func main() {
    	go hello(".")
    	go hello("x")
    	fmt.Println("last line of main")
    	// wait 
    	//Option1 - sleep time 
    	//Option2 - wait for some input
    	x:=0
    	fmt.Scan(&x)
    	//Option3 - infinite loop 
    	//for{}
    }
    
    func hello(str string) {
    	for i := 0; i < 1000; i++ {
    		fmt.Print(str)
    	}
    }
    

Lab4 - create two interfaces -> shift and draw -> with one method each 
                create two structures -> Point2D and Point3D 
                and both should implements both the interfaces 
Lab3 - Lab3.go
        package main
        
        import "fmt"
        type Display interface{
        	Print()
        }
        type Dept struct{
        	Deptno int 
        	Dname string
        }
        func (d Dept) Print(){
        	fmt.Println("in print of dept" ,d)
        }
        
        func main(){
        	d1 := Dept{10,"Vaishali"}
        	fmt.Println(d1)
        	var display Display
        	display = d1
        	display.Print()
        	fmt.Println(display)
        }
Lab2 - Demo2/Emp.go 
        Struct - empno, ename, salary 
        2 receiver methods -> print, salaryincr which should accept percent int
       Demo2/EmpManager.go
        slice of Emp, add method - accept emp and add it to slice, 
                      print method -> print all employees (range -> for i, v := range slice {	}}
  
Lab1 - Demo2/Lab2.go
        package main
        import "fmt"
        type Point struct{
        	X int
        	Y int 
        }
        func (p1 Point) print2(){
        	fmt.Println("Print of Point ", p1)
        }
        func (p1 *Point) shift(dx , dy int ){
        	p1.X += dx
        	p1.Y +=dy
        	fmt.Println("p1 in shift = " , p1)
        }
        func main(){
        	p1 := Point{10,100}
        	fmt.Println("p1 before shift " , p1)
        	p1.shift(5,5)
        	fmt.Println("p1 after Shift " , p1)
        	p1.print2()
        	
        }
